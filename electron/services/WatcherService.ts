/**
 * Watcher Service
 * File watching and auto-commit engine
 * Migrated from: cs-devops-agent-worker.js
 */

import { BaseService } from './BaseService';
import { IPC } from '../../shared/ipc-channels';
import type {
  FileChangeEvent,
  CommitTriggerEvent,
  CommitCompleteEvent,
  IpcResult,
} from '../../shared/types';
import type { GitService } from './GitService';
import type { ActivityService } from './ActivityService';
import type { TerminalLogService } from './TerminalLogService';
import type { AgentInstanceService } from './AgentInstanceService';
import type { LockService } from './LockService';
import type { ASTParserService } from './analysis/ASTParserService';
import type { RepositoryAnalysisService } from './analysis/RepositoryAnalysisService';
import { databaseService } from './DatabaseService';
import type { AgentType } from '../../shared/types';
import chokidar, { FSWatcher } from 'chokidar';
import { promises as fs } from 'fs';
import { existsSync } from 'fs';
import path from 'path';

interface WatcherInstance {
  sessionId: string;
  worktreePath: string;
  watcher: FSWatcher;
  commitMsgFile: string;
  claudeCommitMsgFile: string; // Fallback: .claude-commit-msg
  repoPath: string;           // Main repo path (for locking)
  agentType: AgentType;       // Agent type (for locking)
  branchName?: string;        // Branch name (for locking)
}

export class WatcherService extends BaseService {
  private watchers: Map<string, WatcherInstance> = new Map();
  private gitService: GitService;
  private activityService: ActivityService;
  private terminalLogService: TerminalLogService | null = null;
  private agentInstanceService: AgentInstanceService | null = null;
  private lockService: LockService | null = null;
  private debounceTimers: Map<string, NodeJS.Timeout> = new Map();

  // Phase 4: Analysis services for incremental analysis
  private astParser: ASTParserService | null = null;
  private repositoryAnalysis: RepositoryAnalysisService | null = null;
  private incrementalAnalysisEnabled = false;
  private analysisDebounceTimers: Map<string, NodeJS.Timeout> = new Map();

  // Auto-lock: Enable/disable file locking on change
  private autoLockEnabled = true;

  constructor(git: GitService, activity: ActivityService) {
    super();
    this.gitService = git;
    this.activityService = activity;
  }

  /**
   * Set analysis services for incremental analysis (Phase 4)
   */
  setAnalysisServices(
    astParser: ASTParserService,
    repositoryAnalysis: RepositoryAnalysisService
  ): void {
    this.astParser = astParser;
    this.repositoryAnalysis = repositoryAnalysis;
    console.log('[WatcherService] Analysis services configured for incremental analysis');
  }

  /**
   * Enable/disable incremental analysis on file changes
   */
  setIncrementalAnalysisEnabled(enabled: boolean): void {
    this.incrementalAnalysisEnabled = enabled;
    console.log(`[WatcherService] Incremental analysis ${enabled ? 'enabled' : 'disabled'}`);
  }

  /**
   * Set the agent instance service for tracking commits (crash recovery)
   */
  setAgentInstanceService(agentInstance: AgentInstanceService): void {
    this.agentInstanceService = agentInstance;
  }

  /**
   * Set the terminal log service for logging to terminal view
   */
  setTerminalLogService(terminalLog: TerminalLogService): void {
    this.terminalLogService = terminalLog;
  }

  /**
   * Set the lock service for auto-locking files on change
   */
  setLockService(lockService: LockService): void {
    this.lockService = lockService;
    console.log('[WatcherService] LockService configured for auto-locking');
  }

  /**
   * Enable/disable auto-locking of files when they change
   */
  setAutoLockEnabled(enabled: boolean): void {
    this.autoLockEnabled = enabled;
    console.log(`[WatcherService] Auto-locking ${enabled ? 'enabled' : 'disabled'}`);
  }

  async start(sessionId: string): Promise<IpcResult<void>> {
    return this.wrap(async () => {
      if (this.watchers.has(sessionId)) {
        return; // Already watching
      }

      // Get session worktree path from git service
      // This would normally come from SessionService, but we'll use a simple approach
      const worktreePath = await this.getWorktreePath(sessionId);
      if (!worktreePath) {
        throw new Error('Session worktree not found - use startWithPath instead');
      }

      return this.startWithPath(sessionId, worktreePath);
    }, 'WATCHER_START_FAILED');
  }

  /**
   * Start watching a specific path (called by AgentInstanceService)
   * @param sessionId - Session ID
   * @param worktreePath - Path to the worktree to watch
   * @param agentType - Type of agent (for auto-locking)
   * @param branchName - Branch name (for auto-locking)
   */
  async startWithPath(
    sessionId: string,
    worktreePath: string,
    agentType: AgentType = 'custom',
    branchName?: string
  ): Promise<IpcResult<void>> {
    return this.wrap(async () => {
      if (this.watchers.has(sessionId)) {
        return; // Already watching
      }

      // Register the worktree with GitService so commits can work
      // For worktrees, repoPath is the parent of local_deploy
      const repoPath = worktreePath.includes('/local_deploy/')
        ? worktreePath.split('/local_deploy/')[0]
        : worktreePath;
      this.gitService.registerWorktree(sessionId, repoPath, worktreePath);
      console.log(`[WatcherService] Registered worktree for ${sessionId}: ${worktreePath} (repo: ${repoPath})`);

      const shortSessionId = sessionId.replace('sess_', '').slice(0, 8);
      const commitMsgFile = path.join(worktreePath, `.devops-commit-${shortSessionId}.msg`);
      // Also watch for common Claude commit msg file
      const claudeCommitMsgFile = path.join(worktreePath, '.claude-commit-msg');

      // Create watcher - custom ignore function to allow commit msg files
      const watcher = chokidar.watch(worktreePath, {
        ignored: (filePath: string) => {
          const basename = path.basename(filePath);
          // Allow commit message files (dotfiles we want to watch)
          if (basename === '.claude-commit-msg' ||
              basename.startsWith('.devops-commit-') ||
              basename.startsWith('.claude-session-')) {
            return false; // Don't ignore these
          }
          // Ignore other dotfiles and common directories
          if (basename.startsWith('.')) return true;
          if (filePath.includes('node_modules')) return true;
          if (filePath.includes('.git')) return true;
          if (filePath.includes('.worktrees')) return true;
          if (filePath.includes('/dist/')) return true;
          if (filePath.includes('/build/')) return true;
          return false;
        },
        persistent: true,
        ignoreInitial: true,
        awaitWriteFinish: {
          stabilityThreshold: 1000,  // Increased from 500ms for performance
          pollInterval: 500,         // Increased from 100ms for performance
        },
      });

      const instance: WatcherInstance = {
        sessionId,
        worktreePath,
        watcher,
        commitMsgFile,
        claudeCommitMsgFile,
        repoPath,
        agentType,
        branchName,
      };

      // Handle file events
      watcher.on('add', (filePath) => this.handleFileChange(instance, filePath, 'add'));
      watcher.on('change', (filePath) => this.handleFileChange(instance, filePath, 'change'));
      watcher.on('unlink', (filePath) => this.handleFileChange(instance, filePath, 'unlink'));

      watcher.on('error', (error) => {
        this.activityService.log(sessionId, 'error', `Watcher error: ${error.message}`);
      });

      this.watchers.set(sessionId, instance);
      console.log(`[WatcherService] Started watching ${worktreePath} for session ${sessionId}`);
      this.activityService.log(sessionId, 'success', `File watcher started for ${worktreePath}`);
      this.terminalLogService?.logSystem(`Watcher started: ${worktreePath}`, sessionId);
    }, 'WATCHER_START_FAILED');
  }

  async stop(sessionId: string, releaseLocks = true): Promise<IpcResult<void>> {
    return this.wrap(async () => {
      const instance = this.watchers.get(sessionId);
      if (!instance) return;

      await instance.watcher.close();
      this.watchers.delete(sessionId);

      // Clear debounce timer
      const timer = this.debounceTimers.get(sessionId);
      if (timer) {
        clearTimeout(timer);
        this.debounceTimers.delete(sessionId);
      }

      // Release all locks for this session
      if (releaseLocks && this.lockService) {
        const result = await this.lockService.releaseSessionLocks(instance.repoPath, sessionId);
        if (result.success && result.data && result.data > 0) {
          console.log(`[WatcherService] Released ${result.data} locks for session ${sessionId}`);
        }
      }

      this.activityService.log(sessionId, 'info', 'File watcher stopped');
    }, 'WATCHER_STOP_FAILED');
  }

  async isWatching(sessionId: string): Promise<IpcResult<boolean>> {
    return this.success(this.watchers.has(sessionId));
  }

  private handleFileChange(
    instance: WatcherInstance,
    filePath: string,
    type: 'add' | 'change' | 'unlink'
  ): void {
    const { sessionId, commitMsgFile } = instance;
    const relativePath = path.relative(instance.worktreePath, filePath);

    // Emit file change event
    const event: FileChangeEvent = {
      sessionId,
      filePath: relativePath,
      type,
      timestamp: new Date().toISOString(),
    };
    console.log(`[WatcherService] File ${type}: ${relativePath} (session: ${sessionId})`);
    this.emitToRenderer(IPC.FILE_CHANGED, event);

    // Log file activity with path for commit linking
    this.activityService.logFileActivity(
      sessionId,
      'file',
      `File ${type}: ${relativePath}`,
      relativePath,
      { type, fullPath: filePath }
    );

    this.terminalLogService?.log('info', `File ${type}: ${relativePath}`, { sessionId, source: 'Watcher' });

    // Auto-lock the file when it's modified (add or change)
    if (this.autoLockEnabled && this.lockService && (type === 'add' || type === 'change')) {
      this.lockService.autoLockFile(
        instance.repoPath,
        relativePath,
        sessionId,
        instance.agentType,
        instance.branchName
      ).catch(err => {
        console.warn(`[WatcherService] Failed to auto-lock ${relativePath}:`, err);
      });
    }

    // Check if this is a commit message file (either session-specific or .claude-commit-msg)
    const isCommitMsgFile = filePath === instance.commitMsgFile || filePath === instance.claudeCommitMsgFile;
    // Trigger commit on both 'add' (first creation) and 'change' (update) events
    if (isCommitMsgFile && (type === 'change' || type === 'add')) {
      console.log(`[WatcherService] Commit message file ${type}: ${relativePath}`);
      this.triggerCommit(instance, filePath);
    }

    // Phase 4: Trigger incremental analysis for source files
    this.triggerIncrementalAnalysis(instance, filePath, type);
  }

  private async triggerCommit(instance: WatcherInstance, commitMsgFilePath?: string): Promise<void> {
    const { sessionId } = instance;
    // Use the provided path or default to session-specific file
    const commitMsgFile = commitMsgFilePath || instance.commitMsgFile;

    // Debounce commits
    const existingTimer = this.debounceTimers.get(sessionId);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }

    const timer = setTimeout(async () => {
      this.debounceTimers.delete(sessionId);

      try {
        // Read commit message
        if (!existsSync(commitMsgFile)) return;
        const message = (await fs.readFile(commitMsgFile, 'utf8')).trim();
        if (!message) return;

        // Emit commit triggered event
        const triggerEvent: CommitTriggerEvent = {
          sessionId,
          message,
          timestamp: new Date().toISOString(),
        };
        this.emitToRenderer(IPC.COMMIT_TRIGGERED, triggerEvent);
        this.activityService.log(sessionId, 'commit', `Commit triggered: ${message.substring(0, 50)}...`);

        // Perform commit
        const result = await this.gitService.commit(sessionId, message);
        if (!result.success) {
          throw new Error(result.error?.message || 'Commit failed');
        }

        // Clear commit message file
        await fs.writeFile(commitMsgFile, '');

        // Get file count
        const status = await this.gitService.getStatus(sessionId);
        const filesChanged = status.data?.changes.length || 0;

        const commitHash = result.data!.hash;
        const timestamp = new Date().toISOString();

        // Emit commit completed event
        const completeEvent: CommitCompleteEvent = {
          sessionId,
          commitHash,
          message,
          filesChanged,
          timestamp,
        };
        this.emitToRenderer(IPC.COMMIT_COMPLETED, completeEvent);
        this.activityService.log(
          sessionId,
          'success',
          `Commit complete: ${result.data!.shortHash}`
        );

        // Link all uncommitted activities to this commit
        // This associates file changes, messages, etc. with the commit that included them
        try {
          const linkedCount = this.activityService.linkToCommit(sessionId, commitHash);
          console.log(`[WatcherService] Linked ${linkedCount} activities to commit ${result.data!.shortHash}`);
        } catch (error) {
          console.warn('[WatcherService] Failed to link activities to commit:', error);
        }

        // Record the commit in the database for history tracking
        try {
          databaseService.recordCommit(commitHash, sessionId, message, timestamp, {
            filesChanged,
          });
          databaseService.recordSessionEvent(sessionId, 'commit', { message, filesChanged }, commitHash);
        } catch (error) {
          console.warn('[WatcherService] Failed to record commit in database:', error);
        }

        // Track the commit for crash recovery
        if (this.agentInstanceService) {
          this.agentInstanceService.updateLastProcessedCommit(sessionId, commitHash);
        }

        // Auto-push (could be configurable)
        await this.gitService.push(sessionId);
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        this.activityService.log(sessionId, 'error', `Commit failed: ${message}`);
      }
    }, 1000);

    this.debounceTimers.set(sessionId, timer);
  }

  private async getWorktreePath(sessionId: string): Promise<string | null> {
    // This would normally query SessionService
    // For now, return null and let caller handle
    return null;
  }

  /**
   * Trigger incremental analysis for a changed file (Phase 4)
   */
  private triggerIncrementalAnalysis(
    instance: WatcherInstance,
    filePath: string,
    changeType: 'add' | 'change' | 'unlink'
  ): void {
    if (!this.incrementalAnalysisEnabled || !this.astParser) {
      return;
    }

    const { sessionId, worktreePath } = instance;

    // Only analyze source files
    const ext = path.extname(filePath).toLowerCase();
    const sourceExtensions = ['.ts', '.tsx', '.js', '.jsx', '.py', '.go', '.rs'];
    if (!sourceExtensions.includes(ext)) {
      return;
    }

    // Debounce analysis per session
    const existingTimer = this.analysisDebounceTimers.get(sessionId);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }

    const timer = setTimeout(async () => {
      this.analysisDebounceTimers.delete(sessionId);

      try {
        // 1. Invalidate AST cache for the changed file
        if (changeType === 'unlink') {
          // File was deleted - invalidate cache
          this.astParser!.invalidateCache(filePath);
          console.log(`[WatcherService] Invalidated AST cache for deleted file: ${filePath}`);
        } else {
          // File was added or modified - re-parse
          const ast = await this.astParser!.parseFile(filePath);
          if (ast) {
            console.log(`[WatcherService] Re-parsed file: ${filePath} (${ast.exports.length} exports)`);
          }
        }

        // 2. Emit incremental analysis event
        this.emitToRenderer(IPC.ANALYSIS_PROGRESS, {
          phase: 'incremental',
          totalFiles: 1,
          processedFiles: 1,
          currentFile: path.relative(worktreePath, filePath),
          errors: [],
          startedAt: new Date().toISOString(),
        });

        // 3. Optionally trigger full feature re-analysis
        // This is expensive, so only do it for significant changes
        if (this.repositoryAnalysis && changeType !== 'unlink') {
          // Detect which feature this file belongs to
          const relativePath = path.relative(worktreePath, filePath);
          const featureName = relativePath.split(path.sep)[0];

          console.log(`[WatcherService] File ${relativePath} may affect feature: ${featureName}`);
          // Note: Full re-analysis is deferred to user action to avoid performance impact
        }

        this.terminalLogService?.log('info', `Incremental analysis: ${path.basename(filePath)}`, { sessionId, source: 'Analysis' });
      } catch (error) {
        console.error('[WatcherService] Incremental analysis error:', error);
      }
    }, 2000); // 2 second debounce for analysis

    this.analysisDebounceTimers.set(sessionId, timer);
  }

  async dispose(): Promise<void> {
    for (const [sessionId] of this.watchers) {
      await this.stop(sessionId);
    }

    // Clear analysis debounce timers
    for (const timer of this.analysisDebounceTimers.values()) {
      clearTimeout(timer);
    }
    this.analysisDebounceTimers.clear();
  }
}
